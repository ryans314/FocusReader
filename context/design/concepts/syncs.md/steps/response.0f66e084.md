---
timestamp: 'Mon Nov 10 2025 06:42:08 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251110_064208.687450b6.md]]'
content_id: 0f66e084b6054d913762ffdd28c04add32e891896ce520dafcce1e03b9c6c1b6
---

# response:

Here are the synchronization files and the updated `passthrough.ts` and `src/concepts/concepts.ts` based on your journal and the identified routes.

First, a new `Sessioning` concept is provided, as it's a fundamental dependency for authentication and authorization in the syncs.

***

### **File: `src/concepts/Sessioning/SessioningConcept.ts`**

```typescript
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

const PREFIX = "Sessioning" + ".";

// Generic types: User is an external ID
type User = ID;

// Internal entity IDs managed by this concept
type SessionID = ID;

/**
 * Interface representing a Session document in the database.
 * Corresponds to:
 * a set of Sessions with:
 *   a user User
 *   a expiry Datetime
 */
interface SessionDocument {
  _id: SessionID;
  user: User;
  expiry: Date;
}

/**
 * **concept** Sessioning
 *
 * **purpose** track active user sessions and provide session tokens
 *
 * **principle** A user logs in and receives a session token. This token can then be used to
 *              authenticate subsequent requests until it expires or the user logs out.
 */
export default class SessioningConcept {
  private sessionsCollection: Collection<SessionDocument>;
  // Session expiry time in milliseconds (e.g., 1 hour)
  private readonly SESSION_EXPIRY_MS = 60 * 60 * 1000; // 1 hour

  constructor(private readonly db: Db) {
    this.sessionsCollection = this.db.collection(PREFIX + "sessions");
    // Ensure TTL index for automatic session cleanup
    this.sessionsCollection.createIndex(
      { expiry: 1 },
      { expireAfterSeconds: 0 },
    ).catch((e) =>
      console.error("Error creating TTL index for sessions:", e)
    );
  }

  /**
   * login(user: User): (session: Session)
   *
   * **requires** user exists (external ID, validity assumed for this concept's scope).
   *
   * **effects** Creates a new Session document for the given user with an expiry time.
   *            Returns the ID of the newly created session.
   */
  async login(
    { user }: { user: User },
  ): Promise<{ session: SessionID } | { error: string }> {
    const newSessionId = freshID();
    const expiryDate = new Date(Date.now() + this.SESSION_EXPIRY_MS);

    const newSession: SessionDocument = {
      _id: newSessionId,
      user: user,
      expiry: expiryDate,
    };

    await this.sessionsCollection.insertOne(newSession);
    return { session: newSessionId };
  }

  /**
   * logout(session: Session): Empty
   *
   * **requires** session exists and is not expired.
   *
   * **effects** Removes the specified session document, effectively ending the session.
   */
  async logout(
    { session }: { session: SessionID },
  ): Promise<Empty | { error: string }> {
    const result = await this.sessionsCollection.deleteOne({ _id: session });
    if (result.deletedCount === 0) {
      return { error: `Session ${session} not found or already expired.` };
    }
    return {};
  }

  /**
   * _getUser(session: Session): (user: User)[]
   *
   * **requires** session exists and is not expired.
   *
   * **effects** Returns an array containing the user ID associated with the session.
   *            Returns an empty array if the session is invalid or expired.
   */
  async _getUser(
    { session }: { session: SessionID },
  ): Promise<{ user: User }[] | { error: string }> {
    const sessionDoc = await this.sessionsCollection.findOne({ _id: session });

    if (!sessionDoc) {
      return { error: `Session ${session} not found or expired.` };
    }
    // MongoDB's TTL index should handle actual expiry deletion, but we can double check
    if (sessionDoc.expiry < new Date()) {
      // Potentially delete the session here explicitly if TTL hasn't run yet
      await this.sessionsCollection.deleteOne({ _id: session });
      return { error: `Session ${session} has expired.` };
    }

    return [{ user: sessionDoc.user }];
  }
}

```

***

### **File: `src/concepts/concepts.ts` (Updated to include `Sessioning`)**

```typescript
// This file is generated by `deno run build`
// Do not edit this file directly.

export { default as Annotation } from "./Annotation/AnnotationConcept.ts";
export { default as FocusStats } from "./FocusStats/FocusStatsConcept.ts";
export { default as Library } from "./Library/LibraryConcept.ts";
export { default as Profile } from "./Profile/ProfileConcept.ts";
export { default as Requesting } from "./Requesting/RequestingConcept.ts";
export { default as Sessioning } from "./Sessioning/SessioningConcept.ts"; // Add this line
export { default as TextSettings } from "./TextSettings/TextSettingsConcept.ts";
```

***

### **File: `src/passthrough.ts` (Updated inclusions and exclusions)**

```typescript
// src/passthrough.ts
export const inclusions = {
  "/api/Profile/authenticate": "Allow public authentication.",
  "/api/Annotation/createAnnotation": "Allow users to create annotations on their own documents.",
  "/api/Annotation/deleteAnnotation": "Allow users to delete their own annotations.",
  "/api/Annotation/updateAnnotation": "Allow users to update their own annotations.",
  "/api/Annotation/search": "Allow users to search for annotations on their own document.",
  "/api/FocusStats/removeSession": "Allow users to remove their own focus sessions.",
  "/api/FocusStats/_viewStats": "Allow users to view their own focus statistics.",
  "/api/FocusStats/_getSessions": "Allow users to view their own focus sessions.",
  "/api/Library/removeDocument": "Allow users to remove documents from their library.",
  "/api/Library/renameDocument": "Allow users to rename documents in their library.",
  "/api/Library/_getLibraryByUser": "Allow users to retrieve their library details.",
  "/api/Library/_getDocumentsInLibrary": "Allow users to retrieve documents in their library.",
  "/api/Library/_getDocumentDetails": "Allow users to get details of a specific document.",
  "/api/TextSettings/_getUserDefaultSettings": "Allow users to retrieve their default text settings.",
  "/api/TextSettings/_getDocumentCurrentSettings": "Allow users to retrieve a document's current text settings.",
  "/api/Sessioning/login": "Allow users to log in and get a session.",
  "/api/Sessioning/logout": "Allow users to log out and invalidate their session.",
  "/api/Sessioning/_getUser": "Allow clients to query the user associated with a session token."
};

export const exclusions = [
  "/api/Annotation/_registerDocument", // Internal utility for document creation flow
  "/api/Annotation/registerDocument", // Internal utility for document creation flow (temporary alias)
  "/api/Annotation/_deleteDocumentView", // Internal utility for document deletion flow
  "/api/FocusStats/initUser", // Triggered by user creation sync
  "/api/FocusStats/startSession", // Triggered by openDocument sync
  "/api/FocusStats/endSession", // Triggered by closeDocument sync
  "/api/Library/createLibrary", // Triggered by user creation sync
  "/api/Library/createDocument", // Triggered by a specific API endpoint that reifies
  "/api/Library/openDocument", // Triggered by a specific API endpoint that reifies
  "/api/Library/closeDocument", // Triggered by a specific API endpoint that reifies
  "/api/Profile/createAccount", // Triggered by a specific API endpoint that reifies
  "/api/Profile/deleteAccount", // Triggered by a specific API endpoint that reifies
  "/api/Profile/changePassword", // Triggered by a specific API endpoint that reifies
  "/api/Profile/_getUserDetails", // Should only be queried by authenticated user on their own profile or admin
  "/api/Profile/_getAllUsers", // Internal/admin only
  "/api/TextSettings/clearCollections", // Internal/testing
  "/api/TextSettings/isValidFont", // Internal
  "/api/TextSettings/isValidFontSize", // Internal
  "/api/TextSettings/isValidLineHeight", // Internal
  "/api/TextSettings/createUserSettings", // Triggered by user creation or specific default setting API endpoint
  "/api/TextSettings/createDocumentSettings", // Triggered by document creation sync
  "/api/TextSettings/editSettings", // Triggered by a specific API endpoint that reifies
  "/api/TextSettings/_getTextSettings", // Internal
];
```

***

### **File: `src/syncs/app.sync.ts` (All application-specific synchronizations)**

```typescript
import { actions, Frames, Sync } from "@engine";
import {
  Annotation,
  FocusStats,
  Library,
  Profile,
  Requesting,
  Sessioning,
  TextSettings,
} from "@concepts";
import { ID } from "@utils/types.ts";

// Utility function to get default text settings for a user, or a hardcoded default
async function resolveDefaultTextSettings(
  frames: Frames,
  userSymbol: symbol,
): Promise<Frames> {
  let resultFrames = await frames.query(
    TextSettings._getUserDefaultSettings,
    { user: userSymbol },
    { settings: "userDefaultSettings" }, // Alias to avoid direct `settings` collision
  );

  // If no user default settings, add a frame with hardcoded defaults
  if (resultFrames.length === 0) {
    resultFrames = frames.map((f) => ({
      ...f,
      userDefaultSettings: {
        font: "Arial",
        fontSize: 16,
        lineHeight: 24,
      },
    }));
  }
  return resultFrames;
}

// -----------------------------------------------------------------------------
// Account Management Syncs
// -----------------------------------------------------------------------------

/**
 * Sync: CreateUser
 * Handles user registration requests.
 */
export const CreateUser: Sync = ({ request, username, password, user }) => ({
  when: actions([
    Requesting.request,
    { path: "/createAccount", username, password },
    { request },
  ]),
  then: actions([Profile.createAccount, { username, password }, { user }]),
});

/**
 * Sync: CreateUserResponse (Success)
 * Responds to the client upon successful user creation.
 */
export const CreateUserResponse: Sync = ({ request, user }) => ({
  when: actions(
    [Requesting.request, { path: "/createAccount" }, { request }],
    [Profile.createAccount, {}, { user }],
  ),
  then: actions([Requesting.respond, { request, user }]),
});

/**
 * Sync: CreateUserResponse (Error)
 * Responds to the client upon failed user creation.
 */
export const CreateUserResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/createAccount" }, { request }],
    [Profile.createAccount, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

/**
 * Sync: InitUserDependencies
 * Initializes FocusStats, Library, and default TextSettings when a user is created.
 */
export const InitUserDependencies: Sync = (
  { user, focusStats, library, settings },
) => ({
  when: actions([Profile.createAccount, {}, { user }]),
  then: actions(
    [FocusStats.initUser, { user }, { focusStats }],
    [Library.createLibrary, { user }, { library }],
    [
      TextSettings.createUserSettings,
      {
        user,
        font: "Arial",
        fontSize: 16,
        lineHeight: 24,
      },
      { settings }, // Creates default text settings for the new user
    ],
  ),
});

/**
 * Sync: DeleteAccount
 * Handles requests to delete a user's account.
 */
export const DeleteAccount: Sync = (
  { request, session, user, profileUser, error },
) => ({
  when: actions([
    Requesting.request,
    { path: "/deleteAccount", session },
    { request },
  ]),
  where: async (frames) => {
    // Authenticate user via session
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    if (frames.length === 0) {
      return new Frames({ ...frames[0], [error]: "Invalid session" });
    }
    // For now, assume user is the profileUser; ideally, confirm match if ID passed in request
    frames = frames.map((f) => ({ ...f, [profileUser]: f[user] }));
    return frames;
  },
  then: actions([
    Profile.deleteAccount,
    { user: profileUser }, // Use profileUser for deleteAccount
  ]),
});

/**
 * Sync: DeleteAccountResponse
 * Responds to the client after attempting to delete an account.
 */
export const DeleteAccountResponse: Sync = ({ request, user, error }) => ({
  when: actions(
    [Requesting.request, { path: "/deleteAccount" }, { request }],
    [Profile.deleteAccount, {}, { user, error }], // Catch both success (user) or error
  ),
  then: actions([
    Requesting.respond,
    { request, ...(user && { message: `Account ${user} deleted.` }), ...(error && { error }) },
  ]),
});

/**
 * Sync: ChangePassword
 * Handles requests for changing a user's password.
 */
export const ChangePassword: Sync = (
  { request, session, oldPassword, newPassword, user },
) => ({
  when: actions([
    Requesting.request,
    { path: "/changePassword", session, oldPassword, newPassword },
    { request },
  ]),
  where: async (frames) => {
    return await frames.query(Sessioning._getUser, { session }, { user });
  },
  then: actions([
    Profile.changePassword,
    { user, oldPassword, newPassword },
  ]),
});

/**
 * Sync: ChangePasswordResponse
 * Responds to the client after attempting to change password.
 */
export const ChangePasswordResponse: Sync = ({ request, user, error }) => ({
  when: actions(
    [Requesting.request, { path: "/changePassword" }, { request }],
    [Profile.changePassword, {}, { user, error }],
  ),
  then: actions([
    Requesting.respond,
    {
      request,
      ...(user && { message: `Password for user ${user} changed.` }),
      ...(error && { error }),
    },
  ]),
});

/**
 * Sync: UserLogin
 * Handles login requests.
 */
export const UserLogin: Sync = ({ request, username, password }) => ({
  when: actions([
    Requesting.request,
    { path: "/login", username, password },
    { request },
  ]),
  then: actions([Profile.authenticate, { username, password }]),
});

/**
 * Sync: UserLoginResponse
 * Responds to the client with session or error after login attempt.
 */
export const UserLoginResponse: Sync = ({ request, user, session, error }) => ({
  when: actions(
    [Requesting.request, { path: "/login" }, { request }],
    [Profile.authenticate, {}, { user, error }], // Bind user or error
  ),
  where: async (frames) => {
    // If authentication was successful, create a session
    const originalFrames = frames; // Keep original frames before potential empty query
    frames = await frames.query(Sessioning.login, { user }, { session });

    // If session creation failed (e.g., user was not bound), return original frames with error
    if (originalFrames.length > 0 && frames.length === 0) {
      return originalFrames.map(f => ({ ...f, [error]: f[error] || "Failed to create session." }));
    }
    return frames;
  },
  then: actions([Requesting.respond, { request, user, session, error }]), // Respond with user and session or error
});

// -----------------------------------------------------------------------------
// Document Management Syncs
// -----------------------------------------------------------------------------

/**
 * Sync: CreateDocument
 * Handles requests to create a new document in a user's library.
 */
export const CreateDocument: Sync = (
  { request, session, name, epubContent, user, library },
) => ({
  when: actions([
    Requesting.request,
    { path: "/createDocument", session, name, epubContent },
    { request },
  ]),
  where: async (frames) => {
    // Authenticate user
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    if (frames.length === 0) return frames; // Stop if session is invalid

    // Get user's library
    frames = await frames.query(Library._getLibraryByUser, { user }, { library });
    if (frames.length === 0) return frames; // Stop if user has no library

    return frames;
  },
  then: actions([
    Library.createDocument,
    { name, epubContent, library },
  ]),
});

/**
 * Sync: InitDocumentDependencies
 * When a document is created, register it for annotations and set up its default text settings.
 */
export const InitDocumentDependencies: Sync = (
  { document, user, settings, library },
) => ({
  when: actions([Library.createDocument, {}, { document: document }]),
  where: async (frames) => {
    // Need the user (creator) of the document to register it for Annotation concept's view.
    // Also need user for TextSettings to resolve default settings.
    frames = await frames.query(Library._getLibraryByUser, { library }, { user });
    if (frames.length === 0) return frames;

    // Resolve default text settings for the user
    frames = await resolveDefaultTextSettings(frames, user);

    return frames;
  },
  then: actions(
    [
      Annotation.registerDocument,
      { documentId: document, creatorId: user },
    ],
    [
      TextSettings.createDocumentSettings,
      {
        document,
        font: (settings as any).userDefaultSettings.font,
        fontSize: (settings as any).userDefaultSettings.fontSize,
        lineHeight: (settings as any).userDefaultSettings.lineHeight,
      },
      { settings },
    ],
  ),
});

/**
 * Sync: CreateDocumentResponse
 * Responds to the client after document creation, including its ID.
 */
export const CreateDocumentResponse: Sync = (
  { request, document, error },
) => ({
  when: actions(
    [Requesting.request, { path: "/createDocument" }, { request }],
    [Library.createDocument, {}, { document, error }],
  ),
  then: actions([
    Requesting.respond,
    { request, ...(document && { document }), ...(error && { error }) },
  ]),
});

/**
 * Sync: OpenDocument
 * Handles requests to open a document.
 */
export const OpenDocument: Sync = (
  { request, session, documentId, user, libraryId, document },
) => ({
  when: actions([
    Requesting.request,
    { path: "/openDocument", session, document: documentId },
    { request },
  ]),
  where: async (frames) => {
    // Authenticate user
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    if (frames.length === 0) return frames;

    // Get user's library to get library ID for FocusStats
    frames = await frames.query(Library._getLibraryByUser, { user }, { library: libraryId });
    if (frames.length === 0) return frames;

    // Open document in Library concept (also checks if user owns document)
    frames = await frames.query(Library.openDocument, { user, document: documentId }, { document });
    if (frames.length === 0) return frames;

    return frames;
  },
  then: actions([FocusStats.startSession, { user, document, library: libraryId }]),
});

/**
 * Sync: OpenDocumentResponse
 * Responds to the client after opening a document, including document details and text settings.
 */
export const OpenDocumentResponse: Sync = (
  { request, documentId, document, error, focusSession, settings, responseBody },
) => ({
  when: actions(
    [Requesting.request, { path: "/openDocument" }, { request }],
    [Library.openDocument, { document: documentId }, { document, error: "libraryError" }],
    [FocusStats.startSession, { document: documentId }, { focusSession, error: "focusError" }],
  ),
  where: async (frames) => {
    const originalFrame = frames[0];
    const libraryError = originalFrame?.libraryError;
    const focusError = originalFrame?.focusError;

    if (libraryError || focusError) {
      return new Frames({ ...originalFrame, [responseBody]: { error: libraryError || focusError } });
    }

    // Get document current text settings
    frames = await frames.query(
      TextSettings._getDocumentCurrentSettings,
      { document: documentId },
      { settings },
    );

    const docDetails = await new Frames(originalFrame).query(
      Library._getDocumentDetails,
      { document: documentId },
      { document: "docDetails" },
    );
    const doc = docDetails[0]?.docDetails;

    return frames.map((f) => ({
      ...f,
      [responseBody]: {
        document: doc, // Use full document details
        focusSession: f[focusSession],
        textSettings: f[settings] ? f[settings] : null, // Handle case where settings might not exist
      },
    }));
  },
  then: actions([Requesting.respond, { request, response: responseBody }]),
});

/**
 * Sync: CloseDocument
 * Handles requests to close a document.
 */
export const CloseDocument: Sync = (
  { request, session, documentId, user, document, focusSession },
) => ({
  when: actions([
    Requesting.request,
    { path: "/closeDocument", session, document: documentId },
    { request },
  ]),
  where: async (frames) => {
    // Authenticate user
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    if (frames.length === 0) return frames;

    // Close document in Library concept (also checks if user owns document)
    frames = await frames.query(Library.closeDocument, { user, document: documentId }, { document });
    if (frames.length === 0) return frames;

    // Find the currently active focus session for this user and document
    const activeSessionsFrames = await frames.query(
      FocusStats._getSessions,
      { user },
      { focusSession: "allFocusSessions" },
    );

    // Filter to find the one that matches documentId and has endTime: null
    const latestActiveSession = activeSessionsFrames.filter((f) =>
      f.allFocusSessions.document === f[documentId] && f.allFocusSessions.endTime === null
    );

    if (latestActiveSession.length > 0) {
      // Assuming we care about the most recent one if multiple were somehow open
      return frames.map((f) => ({ ...f, [focusSession]: latestActiveSession[0].allFocusSessions._id }));
    }
    return new Frames(); // No active session to close, or error
  },
  then: actions(
    [FocusStats.endSession, { focusSession }], // End the focus session
  ),
});

/**
 * Sync: CloseDocumentResponse
 * Responds to the client after closing a document.
 */
export const CloseDocumentResponse: Sync = (
  { request, documentId, error, focusSession },
) => ({
  when: actions(
    [Requesting.request, { path: "/closeDocument" }, { request }],
    [Library.closeDocument, { document: documentId }, { error: "libraryError" }],
    [FocusStats.endSession, { focusSession }, { error: "focusError" }],
  ),
  where: async (frames) => {
    const originalFrame = frames[0];
    const libraryError = originalFrame?.libraryError;
    const focusError = originalFrame?.focusError;

    if (libraryError || focusError) {
      return new Frames({ ...originalFrame, [error]: libraryError || focusError });
    }
    return frames;
  },
  then: actions([
    Requesting.respond,
    { request, ...(documentId && { document: documentId }), ...(error && { error }) },
  ]),
});

// -----------------------------------------------------------------------------
// Text Settings Management Syncs
// -----------------------------------------------------------------------------

/**
 * Sync: CreateUserDefaultTextSettings (if no existing default)
 */
export const CreateUserDefaultTextSettings: Sync = (
  { request, session, font, fontSize, lineHeight, user, settings },
) => ({
  when: actions([
    Requesting.request,
    { path: "/setDefaultTextSettings", session, font, fontSize, lineHeight },
    { request },
  ]),
  where: async (frames) => {
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    if (frames.length === 0) return frames;
    // Only proceed if no existing default settings
    const existingDefaultFrames = await frames.query(
      TextSettings._getUserDefaultSettings,
      { user },
      {},
    );
    return existingDefaultFrames.length === 0 ? frames : new Frames();
  },
  then: actions([
    TextSettings.createUserSettings,
    { user, font, fontSize, lineHeight },
    { settings },
  ]),
});

/**
 * Sync: EditUserDefaultTextSettings (if existing default)
 */
export const EditUserDefaultTextSettings: Sync = (
  { request, session, font, fontSize, lineHeight, user, settings: textSettingsId, existingSettings },
) => ({
  when: actions([
    Requesting.request,
    { path: "/setDefaultTextSettings", session, font, fontSize, lineHeight },
    { request },
  ]),
  where: async (frames) => {
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    if (frames.length === 0) return frames;
    // Only proceed if existing default settings are found
    frames = await frames.query(
      TextSettings._getUserDefaultSettings,
      { user },
      { settings: existingSettings }, // Get the full settings object
    );
    if (frames.length > 0) {
      // Extract the ID from the existingSettings object
      return frames.map((f) => ({ ...f, [textSettingsId]: f[existingSettings]._id }));
    }
    return new Frames();
  },
  then: actions([
    TextSettings.editSettings,
    { textSettings: textSettingsId, font, fontSize, lineHeight },
    { settings: textSettingsId }, // Output the updated settings ID
  ]),
});

/**
 * Sync: SetUserDefaultTextSettingsResponse
 * Responds to the client after attempting to set/edit default settings.
 */
export const SetUserDefaultTextSettingsResponse: Sync = (
  { request, settings, error },
) => ({
  when: actions(
    [
      Requesting.request,
      { path: "/setDefaultTextSettings" },
      { request },
    ],
    // Match either the create or edit action's successful output
    [
      TextSettings.createUserSettings,
      {},
      { settings, error: "createError" },
    ],
    [
      TextSettings.editSettings,
      {},
      { settings, error: "editError" }, // settings will be the ID
    ],
  ),
  where: async (frames) => {
    const collectedErrors = frames.collectAs(["createError", "editError"], "allErrors");
    return collectedErrors.map(f => {
      const actualError = f.allErrors.find(e => e.createError || e.editError);
      return {
        ...f,
        [error]: actualError ? (actualError.createError || actualError.editError) : null
      }
    }).filter(f => f[error] !== null || frames.some(fr => fr[settings])); // Keep if there's an error or if settings were returned
  },
  then: actions([
    Requesting.respond,
    {
      request,
      ...(settings && { settings }), // If settings (ID) is returned
      ...(error && { error }),
    },
  ]),
});


/**
 * Sync: EditDocumentTextSettings
 * Handles requests to edit a specific document's text settings.
 */
export const EditDocumentTextSettings: Sync = (
  { request, session, documentId, font, fontSize, lineHeight, user, currentSettings, textSettingsId },
) => ({
  when: actions([
    Requesting.request,
    { path: "/editDocumentTextSettings", session, document: documentId, font, fontSize, lineHeight },
    { request },
  ]),
  where: async (frames) => {
    // Authenticate user
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    if (frames.length === 0) return frames;

    // Check if user owns the document (implicitly by trying to get its settings)
    frames = await frames.query(
      TextSettings._getDocumentCurrentSettings,
      { document: documentId },
      { settings: currentSettings },
    );
    if (frames.length === 0) {
      // If no current settings, it means the document doesn't exist or isn't set up
      return new Frames({ ...frames[0], error: "Document or its current settings not found." });
    }

    // Extract the actual ID of the current settings
    return frames.map((f) => ({ ...f, [textSettingsId]: f[currentSettings]._id }));
  },
  then: actions([
    TextSettings.editSettings,
    { textSettings: textSettingsId, font, fontSize, lineHeight },
    { settings: textSettingsId }, // Output the updated settings ID
  ]),
});

/**
 * Sync: EditDocumentTextSettingsResponse
 * Responds to the client after attempting to edit document settings.
 */
export const EditDocumentTextSettingsResponse: Sync = (
  { request, settings, error },
) => ({
  when: actions(
    [
      Requesting.request,
      { path: "/editDocumentTextSettings" },
      { request },
    ],
    [TextSettings.editSettings, {}, { settings, error }], // settings will be the ID
  ),
  then: actions([
    Requesting.respond,
    {
      request,
      ...(settings && { settings }),
      ...(error && { error }),
    },
  ]),
});

```
